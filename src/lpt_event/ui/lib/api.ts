/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * lpt-event
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export type ComplexValueDisplay = string | null;

export type ComplexValuePrimary = boolean | null;

export type ComplexValueRef = string | null;

export type ComplexValueType = string | null;

export type ComplexValueValue = string | null;

export interface ComplexValue {
  display?: ComplexValueDisplay;
  primary?: ComplexValuePrimary;
  ref?: ComplexValueRef;
  type?: ComplexValueType;
  value?: ComplexValueValue;
}

/**
 * Payload for creating an event (Pydantic-only, with URL validation).

Uses pure Pydantic (not SQLModel) to leverage rich validation types like HttpUrl.
The HttpUrl type ensures picture_url is a valid URL format before accepting it.
 */
export interface EventCreate {
  title: string;
  short_description: string;
  detailed_description: string;
  city: string;
  days_of_week: string[];
  cost_usd: number;
  /**
   * @minLength 1
   * @maxLength 2083
   */
  picture_url: string;
}

/**
 * Payload returned to clients (includes ID and database values).

This model is used to serialize Event table rows into JSON responses.
 */
export interface EventRead {
  id: number;
  title: string;
  short_description: string;
  detailed_description: string;
  city: string;
  days_of_week: string[];
  cost_usd: number;
  picture_url: string;
}

export type EventUpdateTitle = string | null;

export type EventUpdateShortDescription = string | null;

export type EventUpdateDetailedDescription = string | null;

export type EventUpdateCity = string | null;

export type EventUpdateDaysOfWeek = string[] | null;

export type EventUpdateCostUsd = number | null;

export type EventUpdatePictureUrl = string | null;

/**
 * Payload for updating an event (all fields optional).

All fields are optional to support partial updates.
Only fields provided in the request will be updated in the database.
 */
export interface EventUpdate {
  title?: EventUpdateTitle;
  short_description?: EventUpdateShortDescription;
  detailed_description?: EventUpdateDetailedDescription;
  city?: EventUpdateCity;
  days_of_week?: EventUpdateDaysOfWeek;
  cost_usd?: EventUpdateCostUsd;
  picture_url?: EventUpdatePictureUrl;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type NameFamilyName = string | null;

export type NameGivenName = string | null;

export interface Name {
  family_name?: NameFamilyName;
  given_name?: NameGivenName;
}

export type UserActive = boolean | null;

export type UserDisplayName = string | null;

export type UserEmails = ComplexValue[] | null;

export type UserEntitlements = ComplexValue[] | null;

export type UserExternalId = string | null;

export type UserGroups = ComplexValue[] | null;

export type UserId = string | null;

export type UserName = Name | null;

export type UserRoles = ComplexValue[] | null;

export type UserSchemas = UserSchema[] | null;

export type UserUserName = string | null;

export interface User {
  active?: UserActive;
  display_name?: UserDisplayName;
  emails?: UserEmails;
  entitlements?: UserEntitlements;
  external_id?: UserExternalId;
  groups?: UserGroups;
  id?: UserId;
  name?: UserName;
  roles?: UserRoles;
  schemas?: UserSchemas;
  user_name?: UserUserName;
}

export type UserSchema = typeof UserSchema[keyof typeof UserSchema];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSchema = {
  'urn:ietf:params:scim:schemas:core:20:User': 'urn:ietf:params:scim:schemas:core:2.0:User',
  'urn:ietf:params:scim:schemas:extension:workspace:20:User': 'urn:ietf:params:scim:schemas:extension:workspace:2.0:User',
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * API version information response model.

Returns the current version of the application API, extracted from
the package metadata (__version__).

Attributes:
    version (str): Semantic version string (e.g., "1.0.0").

Example:
    >>> version_info = VersionOut.from_metadata()
    >>> print(version_info.version)
    1.0.0
 */
export interface VersionOut {
  version: string;
}

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Return application version from package metadata.
 * @summary Version
 */
export const version = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<VersionOut>> => {
    
    
    return axios.default.get(
      `/api/version`,options
    );
  }




export const getVersionQueryKey = () => {
    return [
    `/api/version`
    ] as const;
    }

    
export const getVersionQueryOptions = <TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVersionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({ signal }) => version({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VersionQueryResult = NonNullable<Awaited<ReturnType<typeof version>>>
export type VersionQueryError = AxiosError<unknown>


export function useVersion<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVersion<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVersion<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Version
 */

export function useVersion<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVersionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getVersionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVersionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({ signal }) => version({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VersionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof version>>>
export type VersionSuspenseQueryError = AxiosError<unknown>


export function useVersionSuspense<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVersionSuspense<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVersionSuspense<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Version
 */

export function useVersionSuspense<TData = Awaited<ReturnType<typeof version>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVersionSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Mocked current-user endpoint for local development.

In production on Databricks Apps, the APX framework provides a real
current-user endpoint that returns the authenticated user's information.
This mock allows the frontend to work seamlessly in local development
without requiring OAuth/OBO tokens.
 * @summary Me Mock
 */
export const currentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.get(
      `/api/current-user`,options
    );
  }




export const getCurrentUserQueryKey = () => {
    return [
    `/api/current-user`
    ] as const;
    }

    
export const getCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({ signal }) => currentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof currentUser>>>
export type CurrentUserQueryError = AxiosError<unknown>


export function useCurrentUser<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUser<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUser<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Me Mock
 */

export function useCurrentUser<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCurrentUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({ signal }) => currentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof currentUser>>>
export type CurrentUserSuspenseQueryError = AxiosError<unknown>


export function useCurrentUserSuspense<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserSuspense<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserSuspense<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Me Mock
 */

export function useCurrentUserSuspense<TData = Awaited<ReturnType<typeof currentUser>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * List all events from the database.

Returns whatever is in the database - seeding of demo data happens during startup.
 * @summary List Events
 */
export const listEvents = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead[]>> => {
    
    
    return axios.default.get(
      `/api/events`,options
    );
  }




export const getListEventsQueryKey = () => {
    return [
    `/api/events`
    ] as const;
    }

    
export const getListEventsQueryOptions = <TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvents>>> = ({ signal }) => listEvents({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListEventsQueryResult = NonNullable<Awaited<ReturnType<typeof listEvents>>>
export type ListEventsQueryError = AxiosError<HTTPValidationError>


export function useListEvents<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvents>>,
          TError,
          Awaited<ReturnType<typeof listEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEvents<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEvents>>,
          TError,
          Awaited<ReturnType<typeof listEvents>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEvents<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Events
 */

export function useListEvents<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListEventsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getListEventsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEventsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvents>>> = ({ signal }) => listEvents({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListEventsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof listEvents>>>
export type ListEventsSuspenseQueryError = AxiosError<HTTPValidationError>


export function useListEventsSuspense<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEventsSuspense<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEventsSuspense<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Events
 */

export function useListEventsSuspense<TData = Awaited<ReturnType<typeof listEvents>>, TError = AxiosError<HTTPValidationError>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListEventsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new event.

The payload uses Pydantic's HttpUrl for validation, but we store it as a plain string
in the database to avoid SQLAlchemy type complexity.
 * @summary Create Event
 */
export const createEvent = (
    eventCreate: EventCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.default.post(
      `/api/events`,
      eventCreate,options
    );
  }



export const getCreateEventMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEvent>>, TError,{data: EventCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createEvent>>, TError,{data: EventCreate}, TContext> => {

const mutationKey = ['createEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEvent>>, {data: EventCreate}> = (props) => {
          const {data} = props ?? {};

          return  createEvent(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEventMutationResult = NonNullable<Awaited<ReturnType<typeof createEvent>>>
    export type CreateEventMutationBody = EventCreate
    export type CreateEventMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Event
 */
export const useCreateEvent = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEvent>>, TError,{data: EventCreate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createEvent>>,
        TError,
        {data: EventCreate},
        TContext
      > => {

      const mutationOptions = getCreateEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Fetch a single event by ID.

Returns 404 if event doesn't exist.
 * @summary Get Event
 */
export const getEvent = (
    eventId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.default.get(
      `/api/events/${eventId}`,options
    );
  }




export const getGetEventQueryKey = (eventId?: number,) => {
    return [
    `/api/events/${eventId}`
    ] as const;
    }

    
export const getGetEventQueryOptions = <TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvent>>> = ({ signal }) => getEvent(eventId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(eventId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventQueryResult = NonNullable<Awaited<ReturnType<typeof getEvent>>>
export type GetEventQueryError = AxiosError<HTTPValidationError>


export function useGetEvent<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvent>>,
          TError,
          Awaited<ReturnType<typeof getEvent>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEvent<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEvent>>,
          TError,
          Awaited<ReturnType<typeof getEvent>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEvent<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event
 */

export function useGetEvent<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventQueryOptions(eventId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGetEventSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(eventId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEventQueryKey(eventId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvent>>> = ({ signal }) => getEvent(eventId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEventSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getEvent>>>
export type GetEventSuspenseQueryError = AxiosError<HTTPValidationError>


export function useGetEventSuspense<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventSuspense<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEventSuspense<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event
 */

export function useGetEventSuspense<TData = Awaited<ReturnType<typeof getEvent>>, TError = AxiosError<HTTPValidationError>>(
 eventId: number, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getEvent>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEventSuspenseQueryOptions(eventId,options)

  const query = useSuspenseQuery(queryOptions, queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing event with partial data.

Only fields provided in the payload will be updated.
All fields are optional in EventUpdate model.
 * @summary Update Event
 */
export const updateEvent = (
    eventId: number,
    eventUpdate: EventUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventRead>> => {
    
    
    return axios.default.put(
      `/api/events/${eventId}`,
      eventUpdate,options
    );
  }



export const getUpdateEventMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEvent>>, TError,{eventId: number;data: EventUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateEvent>>, TError,{eventId: number;data: EventUpdate}, TContext> => {

const mutationKey = ['updateEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEvent>>, {eventId: number;data: EventUpdate}> = (props) => {
          const {eventId,data} = props ?? {};

          return  updateEvent(eventId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEventMutationResult = NonNullable<Awaited<ReturnType<typeof updateEvent>>>
    export type UpdateEventMutationBody = EventUpdate
    export type UpdateEventMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Event
 */
export const useUpdateEvent = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEvent>>, TError,{eventId: number;data: EventUpdate}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateEvent>>,
        TError,
        {eventId: number;data: EventUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete an event by ID.

Returns 404 if event doesn't exist.
Returns success message if deletion succeeds.
 * @summary Delete Event
 */
export const deleteEvent = (
    eventId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/events/${eventId}`,options
    );
  }



export const getDeleteEventMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: number}, TContext> => {

const mutationKey = ['deleteEvent'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEvent>>, {eventId: number}> = (props) => {
          const {eventId} = props ?? {};

          return  deleteEvent(eventId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEventMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEvent>>>
    
    export type DeleteEventMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Event
 */
export const useDeleteEvent = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEvent>>, TError,{eventId: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteEvent>>,
        TError,
        {eventId: number},
        TContext
      > => {

      const mutationOptions = getDeleteEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
